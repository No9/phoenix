#!/usr/bin/env nodejs
var nomnom     = require('nomnom');
var fs         = require('fs');
var http       = require('http');
var pull       = require('pull-stream');
var prettydate = require('pretty-date');
var toStream   = require('pull-stream-to-stream');
var toPull     = require('stream-to-pull-stream');
var prpc       = require('phoenix-rpc');
// var apps       = require('./js/apps');
var cfg        = require('./js/common/config');

function namefileHelp() {
	console.log('You don\'t have a secret.name yet; run \'phoenix setup\' first.');
}

function padleft(width, str) {
	if (str.length < width) {
		return '                                        '.slice(0, width - str.length) + str;
	}
	return str;
}

function padright(width, str) {
	if (str.length < width) {
		return str + '                                        '.slice(0, width - str.length);
	}
	return str;
}

function setup(opts) {
	var nicknameRE = /^[A-z][0-9A-z_-]*$/;
	var nickname;
	var rl = require('readline').createInterface({ input: process.stdin, output: process.stdout });

	// :TODO: dont publish new profile if one already exists

	prpc.createServerOrConnect(cfg, function(err, backend) {
		if (err) return console.error(err);

		// Setup profile
		rl.question('Nickname? > ', handleNickname);
		function handleNickname(input) {
			if (!nicknameRE.test(input)) {
				console.log('Letters, numbers, dashes and underscores only. Must start with a letter.');
				return rl.close(), backend.close();
			}
			nickname = input;
			console.log('\nNickname is \'' + nickname + '\'');
			rl.question('Publish? [y/N]> ', handlePublish);
		}
		function handlePublish(input) {
			console.log('');
			rl.close();
			if (input.toLowerCase() != 'y')
				return console.log('Aborted.'), backend.close();

			// Setup keys
			backend.createKeys(opts['force-new-keypair'], handleKeycreate);
		}
		function handleKeycreate(err) {
			if (err && err.fatal)
				return console.error(err.toString()), backend.close();

			// Publish profile :TODO:
			/*apps.create('profile', {nickname: nickname}, handleProfpublish);
		}
		function handleProfpublish(err) {
			if (err) return console.error('Failed to publish profile', err);*/
			console.log('Ok.');
			console.log('In the future, we\'ll give you usage instructions here.'); // :TODO:
			backend.close();
		}
	});
}
/*
function rebuild(opts) {
	console.log('Clearing the cache...');
	apps.clearCache(function() {
		console.log('Rebuilding...');
		apps.buildCache(function(err) {
			if (err) console.error(err);
			else console.log('Ok.');
		});
	});
}*/

function whoami(opts) {
	prpc.createServerOrConnect(cfg, function(err, backend) {
		if (err) return console.error(err);

		backend.getKeys(function(err, keys) {
			if (err) return console.error(err), backend.close()
			if (keys.exist) {
				console.log('You are:    ' + new Buffer(keys.name).toString('hex'));
				console.log('Public key: ' + new Buffer(keys.public).toString('hex'));
			} else {
				namefileHelp();
			}
			backend.close();
		});
	});
}

function list(opts) {
	function toDetailed (msg) {
		var author = msg.author.toString('hex');
		console.log (
			//proquint.encodeCamelDash(msg.author).substring(0, 43) + ' / ' +
			author.slice(0, 12) + '...' + author.slice(-4) + ' / ' +
			msg.sequence + '\n' +
			msg.type.toString('utf8') + ' : '+
			new Date(msg.timestamp).toISOString() + '\n' +
			( msg.type.toString('utf8') == 'init'
			? msg.message.toString('hex') + '\n'
			: msg.message.toString('utf8') + '\n' )
		);
	}
	function toSimple(msg) {
		// apps.get('profile').getProfile(msg.author, function(err, profile) { :TODO:
			// if (err) return console.error(err);
			var nickname = '???';//(profile) ? profile.nickname : '???';
			// apps.render(msg, function(err, markdown) { :TODO:
				// if (err) markdown = err.toString();
				var markdown = (msg.type.toString() == 'init') ? ('Account created: ' + msg.message.toString('hex').slice(0,16) + '...') : msg.message.toString();
				var author = msg.author.toString('hex');
				var output =
					author.slice(0, 4) + ' | ' +
					padleft(3, ' '+msg.sequence) + ' | ' +
					padleft(14, prettydate.format(new Date(msg.timestamp))) + ' | ' +
					padleft(10, nickname) + ' | ' +
					markdown
				;
				console.log(output);
			// });
		// });
	}
	if (!opts.long) {
		console.log('user   seq   time             nickname     message');
	}
	prpc.createServerOrConnect(cfg, function(err, backend) {
		if (err) return console.error(err);
		pull(
			toPull(backend.createFeedStream({ tail: opts.tail })),
			pull.drain((opts.long) ? toDetailed : toSimple, backend.close.bind(backend))
		);
	});
}

function feeds(opts) {
	prpc.createServerOrConnect(cfg, function(err, backend) {
		if (err) return console.error(err);
		pull(
			toPull(backend.following()),
			pull.collect(function(err, entries) {
				if (err) { return console.error(err); }
				console.log ('  nickname   id');
				entries.forEach(function(entry, i) {
					// apps.get('profile').getProfile(entry.key, function(err, profile) { :TODO:
						var nickname = /*((profile) ? profile.nickname : false) ||*/ '???';
						console.log((i+1) + ' ' + padright(10, nickname) + ' ' + entry.key.toString('hex'));
					// });
				});
				backend.close();
			})
		);
	});
}

/*function lookup(opts) {
	var name = opts.name;

	function output(id) {
		if (opts.pubkey) {
			apps.get('init').getPublicKey(id, function(err, pubkey) {
				if (err) { return console.error(err); }
				console.log(pubkey.toString('hex'));
			});
		} else {
			console.log(id.toString('hex'));
		}
	}

	if (+name == name) {
		// numeric
		var id = (+name - 1);
		pull(
			ssb.following(),
			pull.collect(function(err, entries) {
				if (err) { return console.error(err); }
				var entry = entries[id];
				if (!entry) { return console.error('Invalid user number.'); }
				output(entry.key);
			})
		);
	} else {
		apps.get('profile').lookupByNickname(name, function(err, ids) {
			if (ids.length > 1)
				console.log(ids.length, 'matches');
			ids.forEach(output);
		});
	}
}*/

function post(opts) {
	prpc.createServerOrConnect(cfg, function(err, backend) {
		if (err) return console.error(err);

		backend.getKeys(function(err, keys) {
			if (err) return console.error(err), backend.close();
			if (!keys.exist) return namefileHelp(), backend.close();
			backend.addMessage('text', opts.text, function(err) {
				if (err) console.error(err);
				else console.log('Ok.');
				backend.close();
			});
		});
	});
	

	// :TODO:
	/*apps.create('text', opts.text, function(err) {
		if (err) {
			console.error(err);
		} else {
			console.log('Ok.');
		}
	});*/
}

function follow(opts) {
	prpc.createServerOrConnect(cfg, function(err, backend) {
		if (err) return console.error(err);
		// Validate key
		// :TODO:

		// Add to follow list
		backend.follow(new Buffer(opts.key, 'hex'), function(err) {
			if (err) {
				console.error(err);
			} else {
				console.log('Ok.');
			}
			backend.close();
		});
	});
}

function unfollow(opts) {
	var name = opts.name;
	prpc.createServerOrConnect(cfg, function(err, backend) {
		if (err) return console.error(err);

		function doit(key) {
			// Remove from follow list
			backend.unfollow(key, function(err) {
				if (err) {
					console.error(err);
				} else {
					console.log('Ok.');
				}
				backend.close();
			});
		}

		if (+name == name) {
			// numeric
			var id = (+name - 1);
			pull(
				toPull(backend.following()),
				pull.collect(function(err, entries) {
					if (err) { return console.error(err); }
					var entry = entries[id];
					if (!entry) { return console.error('Invalid user number.'); }
					doit(entry.key);
				})
			);
		} else {
			console.log('Sorry, names got de-implemented.');
			backend.close();
			// :TODO:
			/*apps.get('profile').lookupByNickname(name, function(err, ids) {
				if (ids.length > 1)
					console.log(ids.length, 'matches');
				ids.forEach(doit);
			});*/
		}
	});
}

/*function sign(opts) {
	console.log('Signing ' + opts.path);

	if (!keys.exist) {
		return namefileHelp();
	}

	var buffer;
	try {
		buffer = fs.readFileSync(opts.path);
	} catch (e) {
		console.error('Error: File not found');
		return;
	}

	var sig = keys.sign(buffer);
	console.log('Signature: ' + sig.toString('hex'));
}

function verify(opts) {
	console.log('Verifying ' + opts.path);

	var key = opts.key || keys.public;
	if (!key) {
		return namefileHelp();
	}

	var buffer;
	try {
		buffer = fs.readFileSync(opts.path);
	} catch (e) {
		console.error('Error: File not found');
		return;
	}

	if (keys.verify(buffer, new Buffer(opts.sig, 'hex'), key)) {
		console.log('Success: Signature checks out.');
	} else {
		console.log('Failure: Signature does not match.');
	}
}*/

function addNode(opts) {
	prpc.createServerOrConnect(cfg, function(err, backend) {
		if (err) return console.error(err);

		if (!opts.host)
			return syncNodes(opts, backend);

		var host = opts.host.split(':');
		var addr = host[0];
		var port = +host[1] || 64000;

		backend.addNode(addr, port, function(err) {
			if (err) console.error(err), backend.close();
			else syncNodes(opts, backend);
		});
	});
}

function delNode(opts) {
	prpc.createServerOrConnect(cfg, function(err, backend) {
		if (err) return console.error(err);
	
		var host = opts.host.split(':');
		var addr = host[0];
		var port = +host[1] || 64000;

		console.log('Removing', addr, port);

		backend.delNode(addr, port, function(err) {
			if (err) console.error(err);
			else console.log('Ok.');
			backend.close();
		});
	});
}

function syncNodes(opts, backend) {
	// Establish connections
	var m = 0, n = 0;
	function connectOut(host) {
		var startTs = +(new Date());
		var name = host[0] + ':' + host[1];
		console.log(name + ' connecting.');
		n++;

		var req = http.request({ method: 'CONNECT', hostname: host[0], port: host[1], path: '/' });
		req.on('connect', function(res, stream, head) {
			console.log(name + ' syncing.');
			var rs = backend.createReplicationStream();
			stream.pipe(rs).pipe(stream);
			stream.on('end', function() {
				console.log(name + ' synced. (' + (+(new Date()) - startTs) + 'ms)');
				if (++m == n) onSynced();
			});
			/*
			:TODO: old version below with proper end() cb
			stream.pipe(toStream(ssb.createReplicationStream(function(err) {
				if (err) console.error(err);
				else console.log(name + ' synced. (' + (+(new Date()) - startTs) + 'ms)');
				if (++m == n) onSynced();
			}))).pipe(stream);*/
			// :TODO: spit out some metrics, like # of new messages
		});
		req.on('error', function(e) {
			console.log(name + ' failed, ' + e.message);
		});
		req.end();
	}
	function onSynced() {
		console.log('Ok');
		backend.close();
		/* :TODO:
		console.log('Fast-forwarding application cache.');
		require('./js/apps').buildCache(function(err) { 
			if (err) { return console.error(err); }
			console.log('Ok.');
		});*/
	}
	backend.getNodes(function(err, nodes) {
		if (err) return console.error(err), backend.close();
		if (nodes.length === 0) return console.log('No remote nodes known.\nOk.'), backend.close();
		nodes.forEach(connectOut);
	});
}

nomnom.script('phoenix')
	.option('config', {
		help: 'Sets the config-file (default ./.phoenixrc)'
	});
 nomnom.nocommand()
	.callback(list);
nomnom.command('setup')
	.help('Creates a new profile and feed.')
	.option('force-new-keypair', {
		flag: true,
		help: 'Overwrites your secret.name file with a new keypair if it already exists.'
	})
	.callback(setup);
nomnom.command('feed')
	.help('Shows the feed messages (default action).')
	.options({
		long: {
			flag: true,
			help: 'Flag, output more detailed information.'
		},
		tail: {
			flag: true,
			help: 'Flag, keep output stream open.'
		}
	})
	.callback(list);
nomnom.command('feeds')
	.help('Lists the users you follow.')
	.callback(feeds);
nomnom.command('post')
	.help('Posts a message to your feed.')
	.options({
		text: {
			position: 1,
			required: true,
			help: 'Message-text to post.'
		}
	})
	.callback(post);
nomnom.command('whoami')
	.help('Shows your profile.')
	.callback(whoami);
nomnom.command('follow')
	.help('Starts following a user.')
	.options({
		key: {
			position: 1,
			required: true,
			help: 'Public key to follow.'
		}
	})
	.callback(follow);
nomnom.command('unfollow')
	.help('Stops following a user.')
	.options({
		name: {
			position: 1,
			required: true,
			help: 'Nickname or user number to unfollow.',
		}
	})
	.callback(unfollow);
/*nomnom.command('lookup')
	.help('Looks up a user\'s profile by their nickname.')
	.options({
		name: {
			position: 1,
			required: true,
			help: 'Nickname or user number to lookup.',
		},
		pubkey: {
			flag: true,
			help: 'Flag, output the user\'s public key rather than their id.'
		}
	})
	.callback(lookup);*/
/*nomnom.command('sign')
	.help('Creates a signature for a file.')
	.options({
		path: {
			position: 1,
			required: true,
			help: 'File to sign.',
		}
	})
	.callback(sign);
nomnom.command('verify')
	.help('Verifies a signature for a file.')
	.options({
		path: {
			position: 1,
			required: true,
			help: 'File to verify.',
		},
		sig: {
			position: 2,
			required: true,
			help: 'Signature to verify (hex-encoded).',
		},
		key: {
			position: 3,
			help: 'Public key of the user who created the signature (defaults to yours).'
		}
	})
	.callback(verify);*/
nomnom.command('sync')
	.help('Adds a server to your replication network.')
	.options({
		host: {
			position: 1,
			help: 'Address of the server (<address>[:port]).',
		}
	})
	.callback(addNode);
nomnom.command('unsync')
	.help('Removes a server from your replication network.')
	.options({
		host: {
			position: 1,
			required: true,
			help: 'Address of the server (<address>[:port]).',
		}
	})
	.callback(delNode);
/*nomnom.command('rebuild')
	.help('Reconstructs the application cache from the message logs.')
	.callback(rebuild);*/
nomnom.parse();