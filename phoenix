#!/usr/bin/env node
var nomnom     = require('nomnom');
var proquint   = require('proquint-');
var fs         = require('fs');
var pull       = require('pull-stream');
var prettydate = require('pretty-date');
var keys       = require('./js/common/keys');
var ssb        = require('./js/common/ssb');
var netnodes   = require('./js/common/network-nodes');
var apps       = require('./js/apps');

function namefileHelp() {
	console.log('You don\'t have a ~/.scuttlebutt/secret.name yet; run the \'init\' command.');
}

function padleft(width, str) {
	if (str.length < width) {
		return '                                        '.slice(0, width - str.length) + str;
	}
	return str;
}

function padright(width, str) {
	if (str.length < width) {
		return str + '                                        '.slice(0, width - str.length);
	}
	return str;
}

function newuser(opts) {
	var nicknameRE = /^[A-z][0-9A-z_-]*$/;
	var nickname;
	var rl = require('readline').createInterface({ input: process.stdin, output: process.stdout });
	rl.question('Enter your nickname: ', function(input) {
		if (!nicknameRE.test(input)) {
			console.log('Letters, numbers, dashes and underscores only. Must start with a letter.');
			return rl.close();
		}
		nickname = input;
		rl.question('Your nickname will be \'' + nickname + '\'. Is that right? [y/N] ', function(input) {
			rl.close();
			if (input.toLowerCase() != 'y')
				return console.log('Aborted.');

			// Setup keys
			keys.create(opts['force-new-keypair'], function(err) {
				if (err) {
					if (err.fatal) {
						console.error(err.toString());
						return;
					}
					console.error('Warning' + err.toString().slice(5));
				} else {
					console.log('Keypair created.');
				}
				apps.create('profile',{nickname: nickname}, function(err) {
					if (err) return console.error('Failed to publish profile', err);
					apps.buildCache(function(err) {
						if (err) console.warn('Error building application cache. You may want to run the rebuild command.');
						console.log('Profile message posted. You are: ' + nickname);
						console.log('Hash id:    ' + keys.name.toString('hex'));
						console.log('Public key: ' + keys.public.toString('hex'));
						// process.exit();
					});
				});
			});
		});
	});
}

function rebuild(opts) {
	console.log('Clearing the cache...');
	apps.clearCache(function() {
		console.log('Rebuilding...');
		apps.buildCache(function(err) {
			if (err) console.error(err);
			else console.log('Ok.');
		});
	});
}

function whoami(opts) {
	if (keys.exist) {
		console.log('You are:    ' + keys.name.toString('hex'));
		console.log('Public key: ' + keys.public.toString('hex'));
	} else {
		namefileHelp();
	}
}

function list(opts) {
	function toDetailed (msg) {
		var author = msg.author.toString('hex');
		console.log (
			//proquint.encodeCamelDash(msg.author).substring(0, 43) + ' / ' +
			author.slice(0, 12) + '...' + author.slice(-4) + ' / ' +
			msg.sequence + '\n' +
			msg.type.toString('utf8') + ' : '+
			new Date(msg.timestamp).toISOString() + '\n' +
			( msg.type.toString('utf8') == 'init'
			? msg.message.toString('hex') + '\n'
			: msg.message.toString('utf8') + '\n' )
		);
	}
	function toSimple(msg) {
		apps.render(msg, function(err, markdown) {
			if (err) markdown = err.toString();
			var author = msg.author.toString('hex');
			var output =
				author.slice(0, 12) + '...' + author.slice(-4) + ' | ' +
				padleft(14, prettydate.format(new Date(msg.timestamp))) + ' | ' +
				markdown
			;
			console.log(output);
		});
	}
	pull(
		ssb.createFeedStream({ tail: opts.tail }),
		pull.drain((opts.long) ? toDetailed : toSimple)
	);
}

function feeds(opts) {
	pull(
		ssb.following(),
		pull.collect(function(err, entries) {
			if (err) { return console.error(err); }
			console.log ('  nickname   id');
			entries.forEach(function(entry, i) {
				apps.get('profile').getProfile(entry.key, function(err, profile) {
					var nickname = ((profile) ? profile.nickname : false) || '???';
					console.log((i+1) + ' ' + padright(10, nickname) + ' ' + entry.key.toString('hex'));
				});
			});
		})
	);
}

function lookup(opts) {
	var name = opts.name;

	function output(id) {
		if (opts.pubkey) {
			apps.get('init').getPublicKey(id, function(err, pubkey) {
				if (err) { return console.error(err); }
				console.log(pubkey.toString('hex'));
			});
		} else {
			console.log(id.toString('hex'));
		}
	}

	if (+name == name) {
		// numeric
		var id = (+name - 1);
		pull(
			ssb.following(),
			pull.collect(function(err, entries) {
				if (err) { return console.error(err); }
				var entry = entries[id];
				if (!entry) { return console.error('Invalid user number.'); }
				output(entry.key);
			})
		);
	} else {
		apps.get('profile').lookupByNickname(name, function(err, ids) {
			if (ids.length > 1)
				console.log(ids.length, 'matches');
			ids.forEach(output);
		});
	}
}

function post(opts) {
	if (!keys.exist) {
		return namefileHelp();
	}

	apps.create('text', opts.text, function(err) {
		if (err) {
			console.error(err);
		} else {
			console.log('Ok.');
		}
	});
}

function follow(opts) {
	// Validate key
	// :TODO:

	// Add to follow list
	ssb.follow(new Buffer(opts.key, 'hex'), function(err) {
		if (err) {
			console.error(err);
		} else {
			console.log('Ok.');
		}
	});
}

function unfollow(opts) {
	// Remove from follow list
	ssb.unfollow(opts.key, function(err) {
		if (err) {
			console.error(err);
		} else {
			console.log('Ok.');
		}
	});
}

function sign(opts) {
	console.log('Signing ' + opts.path);

	if (!keys.exist) {
		return namefileHelp();
	}

	var buffer;
	try {
		buffer = fs.readFileSync(opts.path);
	} catch (e) {
		console.error('Error: File not found');
		return;
	}

	var sig = keys.sign(buffer);
	console.log('Signature: ' + sig.toString('hex'));
}

function verify(opts) {
	console.log('Verifying ' + opts.path);

	var key = opts.key || keys.public;
	if (!key) {
		return namefileHelp();
	}

	var buffer;
	try {
		buffer = fs.readFileSync(opts.path);
	} catch (e) {
		console.error('Error: File not found');
		return;
	}

	if (keys.verify(buffer, new Buffer(opts.sig, 'hex'), key)) {
		console.log('Success: Signature checks out.');
	} else {
		console.log('Failure: Signature does not match.');
	}
}

function addNode(opts) {
	var host = opts.host.split(':');
	var addr = host[0];
	var port = host[1] || 64000;

	netnodes.add(addr, port, function(err) {
		if (err) { return console.error(err); }
		console.log('Ok.');
	});
}

function delNode(opts) {
	var host = opts.host.split(':');
	var addr = host[0];
	var port = host[1] || 64000;

	netnodes.del(addr, port, function(err) {
		if (err) { return console.error(err); }
		console.log('Ok.');
	});
}

function listNodes(opts) {
	pull(
		netnodes.createListStream(),
		pull.through(function(node) {
			console.log(node.key[0] + ':' + node.key[1]);
		}),
		pull.drain()
	);
}

nomnom.script('phoenix');
nomnom.nocommand()
	.options({
		long: {
			flag: true,
			help: 'Flag, output more detailed information.'
		},
		tail: {
			flag: true,
			help: 'Flag, keep output stream open.'
		}
	})
	.callback(list);
nomnom.command('newuser')
	.help('Creates a new profile and feed.')
	.option('force-new-keypair', {
		flag: true,
		help: 'Overwrites your ~/.scuttlebutt/secret.name file with a new keypair if it already exists.'
	})
	.callback(newuser);
nomnom.command('rebuild')
	.help('Reconstructs the application cache from the message logs.')
	.callback(rebuild);
nomnom.command('whoami')
	.help('Lists your profile.')
	.callback(whoami);
nomnom.command('list')
	.help('Lists the feed messages.')
	.options({
		long: {
			flag: true,
			help: 'Flag, output more detailed information.'
		},
		tail: {
			flag: true,
			help: 'Flag, keep output stream open.'
		}
	})
	.callback(list);
nomnom.command('feeds')
	.help('Lists the users you follow.')
	.callback(feeds);
nomnom.command('lookup')
	.help('Looks up a user by a nickname.')
	.options({
		name: {
			position: 1,
			required: true,
			help: 'Nickname or user number to lookup.',
		},
		pubkey: {
			flag: true,
			help: 'Flag, output the user\'s public key rather than their id.'
		}
	})
	.callback(lookup);
nomnom.command('post')
	.help('Posts a message to your feed.')
	.options({
		text: {
			position: 1,
			required: true,
			help: 'Message-text to post.'
		}
	})
	.callback(post);
nomnom.command('follow')
	.help('Starts following a user.')
	.options({
		key: {
			position: 1,
			required: true,
			help: 'Public key to follow.'
		}
	})
	.callback(follow);
nomnom.command('unfollow')
	.help('Stops following a user.')
	.options({
		key: {
			position: 1,
			required: true,
			help: 'Public key to unfollow.'
		}
	})
	.callback(unfollow);
nomnom.command('sign')
	.help('Creates a signature for a file.')
	.options({
		path: {
			position: 1,
			required: true,
			help: 'File to sign.',
		}
	})
	.callback(sign);
nomnom.command('verify')
	.help('Verifies a signature for a file.')
	.options({
		path: {
			position: 1,
			required: true,
			help: 'File to verify.',
		},
		sig: {
			position: 2,
			required: true,
			help: 'Signature to verify (hex-encoded).',
		},
		key: {
			position: 3,
			help: 'Public key of the user who created the signature (defaults to yours).'
		}
	})
	.callback(verify);
nomnom.command('add-node')
	.help('Manually adds a node to your replication network.')
	.options({
		host: {
			position: 1,
			required: true,
			help: 'Address of the node (<address>[:port]).',
		}
	})
	.callback(addNode);
nomnom.command('del-node')
	.help('Manually removes a node from your replication network.')
	.options({
		host: {
			position: 1,
			required: true,
			help: 'Address of the node (<address>[:port]).',
		}
	})
	.callback(delNode);
nomnom.command('list-nodes')
	.help('Lists the nodes in your replication network.')
	.callback(listNodes);
nomnom.parse();